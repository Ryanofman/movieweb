        // Node class for visualization
        class Node {
            constructor(movie, x, y, type = 'movie') {
                this.movie = movie;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.type = type;
                this.radius = physics.nodeRadius;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }
            
            update() {
                // Apply damping
                this.vx *= physics.damping;
                this.vy *= physics.damping;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Keep nodes on screen
                if (this.x < this.radius) this.x = this.radius;
                if (this.x > width - this.radius) this.x = width - this.radius;
                if (this.y < this.radius) this.y = this.radius;
                if (this.y > height - this.radius) this.y = height - this.radius;
            }
            
            draw() {
                ctx.save();
                
                // Glow effect
                if (this.type === 'start' || this.type === 'end') {
                    const glowSize = 40 + Math.sin(Date.now() * 0.002 + this.pulsePhase) * 10;
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                    gradient.addColorStop(0, this.type === 'start' ? 'rgba(102, 126, 234, 0.3)' : 'rgba(118, 75, 162, 0.3)');
                    gradient.addColorStop(1, 'rgba(102, 126, 234, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Node circle
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                if (this.type === 'start') {
                    gradient.addColorStop(0, '#8b9fee');
                    gradient.addColorStop(1, '#667eea');
                } else if (this.type === 'end') {
                    gradient.addColorStop(0, '#9f6fc6');
                    gradient.addColorStop(1, '#764ba2');
                } else {
                    gradient.addColorStop(0, '#fbbf24');
                    gradient.addColorStop(1, '#f59e0b');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Movie poster thumbnail
                if (this.movie.poster_path && this.posterImage && this.posterImage.complete) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius - 4, 0, Math.PI * 2);
                    ctx.clip();
                    
                    ctx.drawImage(this.posterImage, this.x - this.radius + 4, this.y - this.radius + 4, 
                                 (this.radius - 4) * 2, (this.radius - 4) * 2);
                    
                    ctx.restore();
                }
                
                // Hover effect
                if (hoveredNode === this) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        // Edge class for visualization
        class Edge {
            constructor(source, target, connection) {
                this.source = source;
                this.target = target;
                this.connection = connection;
                this.particlePhase = Math.random() * Math.PI * 2;
            }
            
            draw() {
                ctx.save();
                
                // Calculate edge position
                const dx = this.target.x - this.source.x;
                const dy = this.target.y - this.source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Draw edge line
                const gradient = ctx.createLinearGradient(this.source.x, this.source.y, this.target.x, this.target.y);
                if (this.connection.role === 'Director') {
                    gradient.addColorStop(0, 'rgba(239, 68, 68, 0.3)');
                    gradient.addColorStop(1, 'rgba(239, 68, 68, 0.3)');
                    ctx.strokeStyle = gradient;
                } else {
                    gradient.addColorStop(0, 'rgba(16, 185, 129, 0.3)');
                    gradient.addColorStop(1, 'rgba(16, 185, 129, 0.3)');
                    ctx.strokeStyle = gradient;
                }
                
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.source.x, this.source.y);
                ctx.lineTo(this.target.x, this.target.y);
                ctx.stroke();
                
                // Animated particles along edge
                const particleCount = 3;
                for (let i = 0; i < particleCount; i++) {
                    const t = ((Date.now() * 0.0005 + this.particlePhase + i / particleCount) % 1);
                    const px = this.source.x + dx * t;
                    const py = this.source.y + dy * t;
                    
                    const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 4);
                    if (this.connection.role === 'Director') {
                        particleGradient.addColorStop(0, 'rgba(239, 68, 68, 0.8)');
                        particleGradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
                    } else {
                        particleGradient.addColorStop(0, 'rgba(16, 185, 129, 0.8)');
                        particleGradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
                    }
                    
                    ctx.fillStyle = particleGradient;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // Check for node hover
            hoveredNode = null;
            for (const node of nodes) {
                const dx = node.x - mouseX;
                const dy = node.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < physics.nodeRadius) {
                    hoveredNode = node;
                    showTooltip(node, e.clientX, e.clientY);
                    canvas.style.cursor = 'pointer';
                    break;
                }
            }
            
            if (!hoveredNode) {
                hideTooltip();
                canvas.style.cursor = 'default';
            }
        });
        
        // Tooltip functions
        function showTooltip(node, x, y) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = '';
            
            if (node.movie.poster_path) {
                const img = document.createElement('img');
                img.src = 'https://image.tmdb.org/t/p/w200' + node.movie.poster_path;
                img.alt = node.movie.title;
                tooltip.appendChild(img);
            }
            
            const title = document.createElement('h3');
            title.textContent = node.movie.title;
            tooltip.appendChild(title);
            
            if (node.movie.release_date) {
                const year = document.createElement('p');
                year.textContent = 'Released: ' + node.movie.release_date.split('-')[0];
                tooltip.appendChild(year);
            }
            
            if (node.movie.overview) {
                const overview = document.createElement('p');
                overview.textContent = node.movie.overview.substring(0, 150) + '...';
                tooltip.appendChild(overview);
            }
            
            tooltip.style.left = x + 20 + 'px';
            tooltip.style.top = y + 20 + 'px';
            tooltip.classList.add('active');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('active');
        }
        
        // Physics simulation
        function applyForces() {
            // Apply repulsion between nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0 && distance < 200) {
                        const force = physics.repulsion / (distance * distance);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        nodes[i].vx -= fx;
                        nodes[i].vy -= fy;
                        nodes[j].vx += fx;
                        nodes[j].vy += fy;
                    }
                }
            }
            
            // Apply spring forces for edges
            for (const edge of edges) {
                const dx = edge.target.x - edge.source.x;
                const dy = edge.target.y - edge.source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const force = (distance - physics.springLength) * physics.springStrength;
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    edge.source.vx += fx;
                    edge.source.vy += fy;
                    edge.target.vx -= fx;
                    edge.target.vy -= fy;
                }
            }
            
            // Apply center gravity
            for (const node of nodes) {
                const dx = physics.centerX - node.x;
                const dy = physics.centerY - node.y;
                node.vx += dx * 0.0001;
                node.vy += dy * 0.0001;
            }
        }

        // Visualize the path
        function visualizePath(result) {
            const nodeMap = new Map();
            
            // Create nodes for movies in the path
            result.path.forEach((movie, index) => {
                const angle = (index / result.path.length) * Math.PI * 2;
                const radius = Math.min(200, Math.max(100, result.path.length * 30));
                const x = physics.centerX + Math.cos(angle) * radius;
                const y = physics.centerY + Math.sin(angle) * radius;
                
                let type = 'movie';
                if (index === 0) type = 'start';
                if (index === result.path.length - 1) type = 'end';
                
                const node = new Node(movie, x, y, type);
                
                // Load poster image
                if (movie.poster_path) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = `https://image.tmdb.org/t/p/w200${movie.poster_path}`;
                    img.onload = () => {
                        node.posterImage = img;
                    };
                }
                
                nodes.push(node);
                nodeMap.set(movie.id, node);
            });
            
            // Create edges
            result.connections.forEach((connection, index) => {
                const sourceNode = nodes[index];
                const targetNode = nodes[index + 1];
                if (sourceNode && targetNode) {
                    edges.push(new Edge(sourceNode, targetNode, connection));
                }
            });
            
            // Display connection info
            displayConnectionInfo(result);
        }
        
        function displayConnectionInfo(result) {
            const info = document.getElementById('connectionInfo');
            let html = '<h4>Connection Path</h4>';
            
            result.connections.forEach((conn, index) => {
                html += `<p><strong>${index + 1}.</strong> ${conn.fromMovie} → ${conn.toMovie}<br>
                         <small>via ${conn.person} (${conn.role})</small></p>`;
            });
            
            info.innerHTML = html;
            info.classList.add('active');
        }

        // Particle background effect
        const particles = [];
        const particleCount = 50;
        
        class BackgroundParticle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 0.5;
                this.opacity = Math.random() * 0.5 + 0.1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Create background particles
        for (let i = 0; i < particleCount; i++) {
            particles.push(new BackgroundParticle());
        }
        
        // Animation loop
        function animate() {
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw background particles
            for (const particle of particles) {
                particle.update();
                particle.draw();
            }
            
            // Update physics
            if (nodes.length > 0) {
                applyForces();
            }
            
            // Update nodes
            for (const node of nodes) {
                node.update();
            }
            
            // Draw edges with glow
            ctx.shadowBlur = 20;
            for (const edge of edges) {
                ctx.shadowColor = edge.connection.role === 'Director' ? 'rgba(239, 68, 68, 0.5)' : 'rgba(16, 185, 129, 0.5)';
                edge.draw();
            }
            ctx.shadowBlur = 0;
            
            // Draw nodes
            for (const node of nodes) {
                node.draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Save graph periodically
        setInterval(() => {
            graphDB.saveToStorage();
        }, 30000); // Every 30 seconds
        
        // Clean up old data periodically
        setInterval(() => {
            graphDB.clearOldData();
        }, 24 * 60 * 60 * 1000); // Once per day
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CineWeb - Movie Connection Network</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1f 0%, #000 100%);
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .search-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            width: 250px;
        }

        .search-box h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
            font-weight: 600;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .movie-item {
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }

        .movie-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }

        .movie-item.selected {
            background: rgba(102, 126, 234, 0.4);
            border: 1px solid #667eea;
        }

        .movie-poster {
            width: 40px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
        }

        .find-path-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            align-self: center;
        }

        .find-path-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(102, 126, 234, 0.5);
        }

        .find-path-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .find-path-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .find-path-btn:hover:before {
            left: 100%;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 300px;
        }

        .tooltip.active {
            opacity: 1;
        }

        .tooltip img {
            width: 80px;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .tooltip h3 {
            font-size: 16px;
            margin-bottom: 4px;
            color: #fff;
        }

        .tooltip p {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin: 4px 0;
        }

        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            line-height: 1.6;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .title {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            pointer-events: none;
            opacity: 0.1;
            letter-spacing: -2px;
        }

        .connection-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            max-width: 300px;
            display: none;
        }

        .connection-info.active {
            display: block;
        }

        .connection-info h4 {
            margin-bottom: 8px;
            color: #667eea;
        }

        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            line-height: 1.6;
        }

        .stats-item {
            margin-bottom: 4px;
            color: rgba(255, 255, 255, 0.7);
        }

        .stats-item strong {
            color: #667eea;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            z-index: 200;
        }

        .search-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            display: none;
            z-index: 150;
        }

        .search-info.active {
            display: block;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    <canvas id="canvas"></canvas>
    
    <h1 class="title">CINEWEB</h1>
    
    <div class="controls">
        <div class="search-box">
            <h3>Start Movie</h3>
            <input type="text" class="search-input" id="startMovieSearch" placeholder="Search for a movie...">
            <div class="search-results" id="startMovieResults"></div>
            <div id="selectedStart"></div>
        </div>

        <button class="find-path-btn" id="findPathBtn" disabled>Connect Movies</button>

        <div class="search-box">
            <h3>End Movie</h3>
            <input type="text" class="search-input" id="endMovieSearch" placeholder="Search for a movie...">
            <div class="search-results" id="endMovieResults"></div>
            <div id="selectedEnd"></div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #667eea;"></div>
            <span>Start Movie</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #764ba2;"></div>
            <span>End Movie</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f59e0b;"></div>
            <span>Connected Movie</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #10b981;"></div>
            <span>Actor Connection</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>Director Connection</span>
        </div>
    </div>
    
    <div class="stats">
        <div class="stats-item"><strong>Graph Nodes:</strong> <span id="graphNodes">0</span></div>
        <div class="stats-item"><strong>Graph Edges:</strong> <span id="graphEdges">0</span></div>
        <div class="stats-item"><strong>Cached Paths:</strong> <span id="cachedPaths">0</span></div>
        <div class="stats-item"><strong>Avg Path Length:</strong> <span id="avgPathLength">0</span></div>
        <div class="stats-item"><strong>Search Speed:</strong> <span id="searchSpeed">0ms</span></div>
    </div>
    
    <div class="search-info" id="searchInfo"></div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <div class="connection-info" id="connectionInfo"></div>

    <script>
        // API Key embedded directly
        const apiKey = '83f5cb6378dcebfca5d214e9b8ddbad3';
        
        // Store selected movies
        let startMovie = null;
        let endMovie = null;
        
        // Debounce function for search
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        // Graph data
        let nodes = [];
        let edges = [];
        let hoveredNode = null;
        
        // Physics settings
        const physics = {
            centerX: width / 2,
            centerY: height / 2,
            springLength: 150,
            springStrength: 0.005,
            repulsion: 5000,
            damping: 0.95,
            nodeRadius: 30
        };
        
        // Advanced Graph Database with indexing and optimization
        class GraphDatabase {
            constructor() {
                // Core data structures
                this.nodes = new Map(); // nodeId -> {id, type, data, neighbors}
                this.edges = new Map(); // edgeId -> {from, to, type, weight, data}
                this.adjacencyList = new Map(); // nodeId -> Set of {nodeId, edgeData}
                this.reverseAdjacencyList = new Map(); // For bidirectional traversal
                
                // Indexes for fast lookups
                this.movieIndex = new Map(); // movieId -> nodeId
                this.personIndex = new Map(); // personId -> nodeId
                this.typeIndex = new Map(); // type -> Set of nodeIds
                this.popularityIndex = new Map(); // nodeId -> popularity score
                
                // Path caching with LRU eviction
                this.pathCache = new Map();
                this.pathCacheOrder = [];
                this.maxPathCacheSize = 1000;
                
                // Precomputed heuristics
                this.heuristicCache = new Map();
                this.collaborationStrength = new Map(); // person -> Map(person -> strength)
                
                // Statistics
                this.stats = {
                    totalNodes: 0,
                    totalEdges: 0,
                    avgDegree: 0,
                    cacheHits: 0,
                    cacheMisses: 0
                };
                
                this.loadFromStorage();
            }
            
            // Generate unique node ID
            generateNodeId(type, id) {
                return `${type}:${id}`;
            }
            
            // Add movie node with metadata
            addMovie(movie) {
                const nodeId = this.generateNodeId('movie', movie.id);
                
                if (!this.nodes.has(nodeId)) {
                    const node = {
                        id: nodeId,
                        type: 'movie',
                        movieId: movie.id,
                        data: {
                            title: movie.title,
                            year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
                            popularity: movie.popularity || 0,
                            poster_path: movie.poster_path,
                            overview: movie.overview,
                            genre_ids: movie.genre_ids || []
                        },
                        neighbors: new Set(),
                        addedAt: Date.now()
                    };
                    
                    this.nodes.set(nodeId, node);
                    this.movieIndex.set(movie.id, nodeId);
                    this.addToTypeIndex('movie', nodeId);
                    this.popularityIndex.set(nodeId, movie.popularity || 0);
                    this.stats.totalNodes++;
                }
                
                return nodeId;
            }
            
            // Add person node
            addPerson(person) {
                const nodeId = this.generateNodeId('person', person.id);
                
                if (!this.nodes.has(nodeId)) {
                    const node = {
                        id: nodeId,
                        type: 'person',
                        personId: person.id,
                        data: {
                            name: person.name,
                            popularity: person.popularity || 0,
                            known_for_department: person.known_for_department
                        },
                        neighbors: new Set(),
                        addedAt: Date.now()
                    };
                    
                    this.nodes.set(nodeId, node);
                    this.personIndex.set(person.id, nodeId);
                    this.addToTypeIndex('person', nodeId);
                    this.stats.totalNodes++;
                }
                
                return nodeId;
            }
            
            // Add edge between nodes
            addEdge(fromNodeId, toNodeId, edgeType, metadata = {}) {
                const edgeId = `${fromNodeId}->${toNodeId}`;
                
                if (!this.edges.has(edgeId)) {
                    const edge = {
                        id: edgeId,
                        from: fromNodeId,
                        to: toNodeId,
                        type: edgeType,
                        weight: this.calculateEdgeWeight(edgeType, metadata),
                        data: metadata
                    };
                    
                    this.edges.set(edgeId, edge);
                    
                    // Update adjacency lists
                    if (!this.adjacencyList.has(fromNodeId)) {
                        this.adjacencyList.set(fromNodeId, new Set());
                    }
                    this.adjacencyList.get(fromNodeId).add({
                        nodeId: toNodeId,
                        edge: edge
                    });
                    
                    if (!this.reverseAdjacencyList.has(toNodeId)) {
                        this.reverseAdjacencyList.set(toNodeId, new Set());
                    }
                    this.reverseAdjacencyList.get(toNodeId).add({
                        nodeId: fromNodeId,
                        edge: edge
                    });
                    
                    // Update node neighbors
                    const fromNode = this.nodes.get(fromNodeId);
                    const toNode = this.nodes.get(toNodeId);
                    if (fromNode) fromNode.neighbors.add(toNodeId);
                    if (toNode) toNode.neighbors.add(fromNodeId);
                    
                    this.stats.totalEdges++;
                    this.updateCollaborationStrength(fromNodeId, toNodeId);
                }
                
                return edgeId;
            }
            
            // Calculate edge weight based on type and metadata
            calculateEdgeWeight(edgeType, metadata) {
                let weight = 1;
                
                if (edgeType === 'director') {
                    weight *= 0.8; // Directors often work with same actors
                } else if (edgeType === 'lead_actor') {
                    weight *= 0.9; // Lead actors are more selective
                } else if (metadata.character && metadata.character.includes('uncredited')) {
                    weight *= 1.5; // Uncredited roles are weaker connections
                }
                
                // Consider billing order
                if (metadata.order !== undefined) {
                    weight *= (1 + metadata.order * 0.1);
                }
                
                return weight;
            }
            
            // Update collaboration strength between people
            updateCollaborationStrength(nodeId1, nodeId2) {
                const node1 = this.nodes.get(nodeId1);
                const node2 = this.nodes.get(nodeId2);
                
                if (node1?.type === 'person' && node2?.type === 'person') {
                    const key1 = `${nodeId1}-${nodeId2}`;
                    const key2 = `${nodeId2}-${nodeId1}`;
                    
                    const currentStrength = this.collaborationStrength.get(key1) || 0;
                    this.collaborationStrength.set(key1, currentStrength + 1);
                    this.collaborationStrength.set(key2, currentStrength + 1);
                }
            }
            
            // Add to type index
            addToTypeIndex(type, nodeId) {
                if (!this.typeIndex.has(type)) {
                    this.typeIndex.set(type, new Set());
                }
                this.typeIndex.get(type).add(nodeId);
            }
            
            // Get or create movie connections
            async getMovieConnections(movieId) {
                const nodeId = this.movieIndex.get(movieId);
                if (nodeId && this.adjacencyList.has(nodeId)) {
                    const neighbors = this.adjacencyList.get(nodeId);
                    if (neighbors.size > 10) { // Already well-connected
                        return Array.from(neighbors);
                    }
                }
                
                // Fetch from API if not cached
                const credits = await this.fetchMovieCredits(movieId);
                return this.processMovieCredits(movieId, credits);
            }
            
            // Fetch movie credits from API
            async fetchMovieCredits(movieId) {
                try {
                    const response = await fetch(
                        `https://api.themoviedb.org/3/movie/${movieId}/credits?api_key=${apiKey}`
                    );
                    return await response.json();
                } catch (error) {
                    console.error('Credits fetch error:', error);
                    return { cast: [], crew: [] };
                }
            }
            
            // Process movie credits and build graph
            processMovieCredits(movieId, credits) {
                const movieNodeId = this.movieIndex.get(movieId);
                if (!movieNodeId) return [];
                
                const connections = [];
                
                // Process cast (limit to top actors by order)
                credits.cast
                    .filter(person => person.order < 20) // Top 20 billed actors
                    .forEach(person => {
                        const personNodeId = this.addPerson(person);
                        const edgeId = this.addEdge(movieNodeId, personNodeId, 
                            person.order < 3 ? 'lead_actor' : 'actor', {
                            character: person.character,
                            order: person.order
                        });
                        connections.push({ nodeId: personNodeId, edge: this.edges.get(edgeId) });
                    });
                
                // Process crew (directors and key positions)
                credits.crew
                    .filter(person => ['Director', 'Producer', 'Writer'].includes(person.job))
                    .forEach(person => {
                        const personNodeId = this.addPerson(person);
                        const edgeId = this.addEdge(movieNodeId, personNodeId, 
                            person.job.toLowerCase(), {
                            job: person.job,
                            department: person.department
                        });
                        connections.push({ nodeId: personNodeId, edge: this.edges.get(edgeId) });
                    });
                
                return connections;
            }
            
            // A* search with heuristics
            async findOptimalPath(startMovieId, endMovieId, onProgress) {
                const startTime = performance.now();
                
                // Check cache first
                const cacheKey = `${startMovieId}-${endMovieId}`;
                const reverseCacheKey = `${endMovieId}-${startMovieId}`;
                
                if (this.pathCache.has(cacheKey)) {
                    this.stats.cacheHits++;
                    const cachedPath = this.pathCache.get(cacheKey);
                    this.updatePathCacheOrder(cacheKey);
                    this.updateSearchSpeed(performance.now() - startTime);
                    return cachedPath;
                }
                
                if (this.pathCache.has(reverseCacheKey)) {
                    this.stats.cacheHits++;
                    const reversePath = this.pathCache.get(reverseCacheKey);
                    this.updatePathCacheOrder(reverseCacheKey);
                    const path = this.reversePath(reversePath);
                    this.updateSearchSpeed(performance.now() - startTime);
                    return path;
                }
                
                this.stats.cacheMisses++;
                
                // Initialize A* search
                const startNodeId = this.movieIndex.get(startMovieId);
                const endNodeId = this.movieIndex.get(endMovieId);
                
                if (!startNodeId || !endNodeId) {
                    throw new Error('Movies not found in database');
                }
                
                // Ensure both movies are in the graph
                await this.getMovieConnections(startMovieId);
                await this.getMovieConnections(endMovieId);
                
                // Priority queue for A* (using array for simplicity, could use heap)
                const openSet = new Map();
                const closedSet = new Set();
                const gScore = new Map();
                const fScore = new Map();
                const cameFrom = new Map();
                
                // Initialize start node
                openSet.set(startNodeId, {
                    nodeId: startNodeId,
                    g: 0,
                    f: this.heuristic(startNodeId, endNodeId),
                    path: [this.nodes.get(startNodeId)]
                });
                gScore.set(startNodeId, 0);
                fScore.set(startNodeId, this.heuristic(startNodeId, endNodeId));
                
                let iterations = 0;
                const maxIterations = 10000;
                let nodesExplored = 0;
                
                while (openSet.size > 0 && iterations < maxIterations) {
                    iterations++;
                    
                    // Get node with lowest f score
                    let current = null;
                    let lowestF = Infinity;
                    for (const [nodeId, data] of openSet) {
                        if (data.f < lowestF) {
                            lowestF = data.f;
                            current = data;
                        }
                    }
                    
                    if (!current) break;
                    
                    // Update progress
                    if (onProgress && iterations % 10 === 0) {
                        onProgress({
                            explored: nodesExplored,
                            queued: openSet.size,
                            current: current.nodeId
                        });
                    }
                    
                    // Check if we reached the goal
                    if (current.nodeId === endNodeId) {
                        const path = this.reconstructPath(cameFrom, current.nodeId, startNodeId);
                        this.cachePath(cacheKey, path);
                        this.updateSearchSpeed(performance.now() - startTime);
                        return path;
                    }
                    
                    openSet.delete(current.nodeId);
                    closedSet.add(current.nodeId);
                    nodesExplored++;
                    
                    // Explore neighbors
                    const neighbors = await this.getNeighbors(current.nodeId);
                    
                    for (const neighbor of neighbors) {
                        if (closedSet.has(neighbor.nodeId)) continue;
                        
                        const tentativeG = gScore.get(current.nodeId) + neighbor.edge.weight;
                        
                        if (!openSet.has(neighbor.nodeId)) {
                            // Discover new node
                            const h = this.heuristic(neighbor.nodeId, endNodeId);
                            openSet.set(neighbor.nodeId, {
                                nodeId: neighbor.nodeId,
                                g: tentativeG,
                                f: tentativeG + h,
                                path: [...current.path, this.nodes.get(neighbor.nodeId)]
                            });
                            gScore.set(neighbor.nodeId, tentativeG);
                            fScore.set(neighbor.nodeId, tentativeG + h);
                            cameFrom.set(neighbor.nodeId, {
                                from: current.nodeId,
                                edge: neighbor.edge
                            });
                        } else if (tentativeG < gScore.get(neighbor.nodeId)) {
                            // Found better path
                            const h = this.heuristic(neighbor.nodeId, endNodeId);
                            const neighborData = openSet.get(neighbor.nodeId);
                            neighborData.g = tentativeG;
                            neighborData.f = tentativeG + h;
                            neighborData.path = [...current.path, this.nodes.get(neighbor.nodeId)];
                            gScore.set(neighbor.nodeId, tentativeG);
                            fScore.set(neighbor.nodeId, tentativeG + h);
                            cameFrom.set(neighbor.nodeId, {
                                from: current.nodeId,
                                edge: neighbor.edge
                            });
                        }
                    }
                }
                
                this.updateSearchSpeed(performance.now() - startTime);
                return null; // No path found
            }
            
            // Heuristic function for A*
            heuristic(nodeId1, nodeId2) {
                // Check cached heuristic
                const cacheKey = `${nodeId1}-${nodeId2}`;
                if (this.heuristicCache.has(cacheKey)) {
                    return this.heuristicCache.get(cacheKey);
                }
                
                const node1 = this.nodes.get(nodeId1);
                const node2 = this.nodes.get(nodeId2);
                
                if (!node1 || !node2) return Infinity;
                
                let h = 2; // Base heuristic (minimum 2 connections needed)
                
                // Both movies: use genre similarity and year difference
                if (node1.type === 'movie' && node2.type === 'movie') {
                    // Genre similarity
                    const genres1 = new Set(node1.data.genre_ids || []);
                    const genres2 = new Set(node2.data.genre_ids || []);
                    const commonGenres = [...genres1].filter(g => genres2.has(g)).length;
                    if (commonGenres > 0) {
                        h *= (1 - commonGenres * 0.1); // Reduce heuristic for similar genres
                    }
                    
                    // Year difference
                    if (node1.data.year && node2.data.year) {
                        const yearDiff = Math.abs(node1.data.year - node2.data.year);
                        h *= (1 + yearDiff * 0.01); // Increase for distant years
                    }
                    
                    // Popularity factor
                    const popularityRatio = Math.min(node1.data.popularity, node2.data.popularity) / 
                                          Math.max(node1.data.popularity, node2.data.popularity);
                    h *= (2 - popularityRatio); // Similar popularity reduces distance
                }
                
                // Person to movie: check if person worked on similar movies
                if ((node1.type === 'person' && node2.type === 'movie') ||
                    (node1.type === 'movie' && node2.type === 'person')) {
                    h = 1; // Direct connection possible
                }
                
                // Person to person: check collaboration history
                if (node1.type === 'person' && node2.type === 'person') {
                    const collabKey = `${nodeId1}-${nodeId2}`;
                    const collaboration = this.collaborationStrength.get(collabKey) || 0;
                    if (collaboration > 0) {
                        h = 0.5; // Very likely to be connected
                    }
                }
                
                this.heuristicCache.set(cacheKey, h);
                return h;
            }
            
            // Get neighbors for a node
            async getNeighbors(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node) return [];
                
                // For movies, ensure we have all connections
                if (node.type === 'movie') {
                    const movieId = node.movieId;
                    await this.getMovieConnections(movieId);
                }
                
                // For people, get their filmography if needed
                if (node.type === 'person' && (!this.adjacencyList.has(nodeId) || 
                    this.adjacencyList.get(nodeId).size < 5)) {
                    await this.getPersonMovies(node.personId);
                }
                
                return Array.from(this.adjacencyList.get(nodeId) || []);
            }
            
            // Get person's movies
            async getPersonMovies(personId) {
                try {
                    const response = await fetch(
                        `https://api.themoviedb.org/3/person/${personId}/movie_credits?api_key=${apiKey}`
                    );
                    const data = await response.json();
                    
                    const personNodeId = this.personIndex.get(personId);
                    if (!personNodeId) return;
                    
                    // Process cast credits
                    data.cast
                        .filter(movie => movie.popularity > 1) // Filter out very obscure movies
                        .sort((a, b) => b.popularity - a.popularity)
                        .slice(0, 30) // Top 30 movies
                        .forEach(movie => {
                            const movieNodeId = this.addMovie(movie);
                            this.addEdge(personNodeId, movieNodeId, 'acted_in', {
                                character: movie.character,
                                popularity: movie.popularity
                            });
                        });
                    
                    // Process crew credits
                    data.crew
                        .filter(movie => ['Director', 'Producer', 'Writer'].includes(movie.job))
                        .sort((a, b) => b.popularity - a.popularity)
                        .slice(0, 20)
                        .forEach(movie => {
                            const movieNodeId = this.addMovie(movie);
                            this.addEdge(personNodeId, movieNodeId, movie.job.toLowerCase(), {
                                job: movie.job,
                                popularity: movie.popularity
                            });
                        });
                    
                } catch (error) {
                    console.error('Person credits error:', error);
                }
            }
            
            // Reconstruct path from A* search
            reconstructPath(cameFrom, current, start) {
                const path = {
                    nodes: [],
                    connections: []
                };
                
                let currentNodeId = current;
                const visitedNodes = [this.nodes.get(currentNodeId)];
                const connections = [];
                
                while (cameFrom.has(currentNodeId)) {
                    const prev = cameFrom.get(currentNodeId);
                    visitedNodes.unshift(this.nodes.get(prev.from));
                    connections.unshift(prev.edge);
                    currentNodeId = prev.from;
                }
                
                // Convert to movie path
                path.path = [];
                for (let i = 0; i < visitedNodes.length; i++) {
                    const node = visitedNodes[i];
                    if (node.type === 'movie') {
                        path.path.push({
                            id: node.movieId,
                            title: node.data.title,
                            release_date: node.data.year ? `${node.data.year}-01-01` : null,
                            poster_path: node.data.poster_path,
                            overview: node.data.overview
                        });
                    }
                }
                
                // Build connections
                for (let i = 0; i < connections.length; i++) {
                    const edge = connections[i];
                    const fromNode = this.nodes.get(edge.from);
                    const toNode = this.nodes.get(edge.to);
                    
                    if (fromNode.type === 'movie' && toNode.type === 'person' && 
                        i + 1 < connections.length) {
                        const nextEdge = connections[i + 1];
                        const nextNode = this.nodes.get(nextEdge.to);
                        
                        if (nextNode.type === 'movie') {
                            path.connections.push({
                                person: toNode.data.name,
                                role: edge.type === 'director' ? 'Director' : 'Actor',
                                fromMovie: fromNode.data.title,
                                toMovie: nextNode.data.title
                            });
                        }
                    }
                }
                
                return path;
            }
            
            // Cache path with LRU eviction
            cachePath(key, path) {
                this.pathCache.set(key, path);
                this.updatePathCacheOrder(key);
                
                // Evict oldest if cache is full
                if (this.pathCache.size > this.maxPathCacheSize) {
                    const oldestKey = this.pathCacheOrder.shift();
                    this.pathCache.delete(oldestKey);
                }
                
                this.updateStats();
            }
            
            // Update path cache order for LRU
            updatePathCacheOrder(key) {
                const index = this.pathCacheOrder.indexOf(key);
                if (index > -1) {
                    this.pathCacheOrder.splice(index, 1);
                }
                this.pathCacheOrder.push(key);
            }
            
            // Reverse a path
            reversePath(path) {
                return {
                    path: path.path.slice().reverse(),
                    connections: path.connections.slice().reverse().map(conn => ({
                        ...conn,
                        fromMovie: conn.toMovie,
                        toMovie: conn.fromMovie
                    }))
                };
            }
            
            // Update statistics
            updateStats() {
                this.stats.avgDegree = this.stats.totalEdges / Math.max(this.stats.totalNodes, 1);
                
                document.getElementById('graphNodes').textContent = this.stats.totalNodes;
                document.getElementById('graphEdges').textContent = this.stats.totalEdges;
                document.getElementById('cachedPaths').textContent = this.pathCache.size;
                
                // Calculate average path length
                let totalLength = 0;
                let pathCount = 0;
                for (const path of this.pathCache.values()) {
                    if (path && path.path) {
                        totalLength += path.path.length;
                        pathCount++;
                    }
                }
                const avgLength = pathCount > 0 ? (totalLength / pathCount).toFixed(1) : 0;
                document.getElementById('avgPathLength').textContent = avgLength;
            }
            
            // Update search speed display
            updateSearchSpeed(time) {
                document.getElementById('searchSpeed').textContent = `${Math.round(time)}ms`;
            }
            
            // Save to localStorage (with compression)
            saveToStorage() {
                try {
                    // Prepare data for storage
                    const data = {
                        nodes: Array.from(this.nodes.entries()).map(([id, node]) => ({
                            id,
                            ...node,
                            neighbors: Array.from(node.neighbors)
                        })),
                        edges: Array.from(this.edges.entries()),
                        pathCache: Array.from(this.pathCache.entries()).slice(-100), // Keep last 100 paths
                        stats: this.stats,
                        timestamp: Date.now()
                    };
                    
                    // Compress using simple JSON stringification (could use LZ-string for better compression)
                    const compressed = JSON.stringify(data);
                    
                    // Split into chunks if too large
                    const chunkSize = 1024 * 1024; // 1MB chunks
                    const chunks = Math.ceil(compressed.length / chunkSize);
                    
                    for (let i = 0; i < chunks; i++) {
                        const chunk = compressed.substr(i * chunkSize, chunkSize);
                        localStorage.setItem(`cineweb_graph_${i}`, chunk);
                    }
                    
                    localStorage.setItem('cineweb_graph_chunks', chunks.toString());
                    
                } catch (e) {
                    console.error('Failed to save graph:', e);
                    // Clear old data if storage is full
                    this.clearOldData();
                }
            }
            
            // Load from localStorage
            loadFromStorage() {
                try {
                    const chunks = parseInt(localStorage.getItem('cineweb_graph_chunks') || '0');
                    if (chunks === 0) return;
                    
                    let compressed = '';
                    for (let i = 0; i < chunks; i++) {
                        compressed += localStorage.getItem(`cineweb_graph_${i}`) || '';
                    }
                    
                    const data = JSON.parse(compressed);
                    
                    // Check if data is too old (7 days)
                    if (Date.now() - data.timestamp > 7 * 24 * 60 * 60 * 1000) {
                        this.clearStorage();
                        return;
                    }
                    
                    // Restore nodes
                    for (const nodeData of data.nodes) {
                        const node = {
                            ...nodeData,
                            neighbors: new Set(nodeData.neighbors)
                        };
                        this.nodes.set(node.id, node);
                        
                        // Rebuild indexes
                        if (node.type === 'movie') {
                            this.movieIndex.set(node.movieId, node.id);
                        } else if (node.type === 'person') {
                            this.personIndex.set(node.personId, node.id);
                        }
                        this.addToTypeIndex(node.type, node.id);
                        if (node.data.popularity) {
                            this.popularityIndex.set(node.id, node.data.popularity);
                        }
                    }
                    
                    // Restore edges and adjacency lists
                    for (const [edgeId, edge] of data.edges) {
                        this.edges.set(edgeId, edge);
                        
                        if (!this.adjacencyList.has(edge.from)) {
                            this.adjacencyList.set(edge.from, new Set());
                        }
                        this.adjacencyList.get(edge.from).add({
                            nodeId: edge.to,
                            edge: edge
                        });
                        
                        if (!this.reverseAdjacencyList.has(edge.to)) {
                            this.reverseAdjacencyList.set(edge.to, new Set());
                        }
                        this.reverseAdjacencyList.get(edge.to).add({
                            nodeId: edge.from,
                            edge: edge
                        });
                    }
                    
                    // Restore path cache
                    this.pathCache = new Map(data.pathCache);
                    this.pathCacheOrder = data.pathCache.map(([key]) => key);
                    
                    // Restore stats
                    this.stats = data.stats;
                    this.updateStats();
                    
                } catch (e) {
                    console.error('Failed to load graph:', e);
                    this.clearStorage();
                }
            }
            
            // Clear storage
            clearStorage() {
                const chunks = parseInt(localStorage.getItem('cineweb_graph_chunks') || '0');
                for (let i = 0; i < chunks; i++) {
                    localStorage.removeItem(`cineweb_graph_${i}`);
                }
                localStorage.removeItem('cineweb_graph_chunks');
            }
            
            // Clear old data
            clearOldData() {
                const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
                
                // Remove old nodes
                for (const [nodeId, node] of this.nodes.entries()) {
                    if (node.addedAt < oneWeekAgo) {
                        this.nodes.delete(nodeId);
                        this.adjacencyList.delete(nodeId);
                        this.reverseAdjacencyList.delete(nodeId);
                        
                        // Remove from indexes
                        if (node.type === 'movie') {
                            this.movieIndex.delete(node.movieId);
                        } else if (node.type === 'person') {
                            this.personIndex.delete(node.personId);
                        }
                    }
                }
                
                // Clear old paths
                this.pathCache.clear();
                this.pathCacheOrder = [];
                
                this.saveToStorage();
            }
        }
        
        // Initialize graph database
        const graphDB = new GraphDatabase();
        
        // Resize handler
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            physics.centerX = width / 2;
            physics.centerY = height / 2;
        });

        // Search for movies
        async function searchMovies(query) {
            try {
                const response = await fetch(
                    `https://api.themoviedb.org/3/search/movie?api_key=${apiKey}&query=${encodeURIComponent(query)}`
                );
                const data = await response.json();
                return data.results || [];
            } catch (error) {
                console.error('Search error:', error);
                return [];
            }
        }

        // Display search results
        function displaySearchResults(movies, resultsContainer, isStart) {
            resultsContainer.innerHTML = '';
            
            if (movies.length === 0) {
                resultsContainer.innerHTML = '<div style="padding: 10px; color: #888;">No results found</div>';
                return;
            }
            
            movies.slice(0, 5).forEach(movie => {
                const movieEl = document.createElement('div');
                movieEl.className = 'movie-item';
                
                // Create elements separately to avoid template literal issues
                if (movie.poster_path) {
                    const img = document.createElement('img');
                    img.src = 'https://image.tmdb.org/t/p/w200' + movie.poster_path;
                    img.className = 'movie-poster';
                    img.alt = movie.title;
                    movieEl.appendChild(img);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'movie-poster';
                    placeholder.style.background = '#333';
                    movieEl.appendChild(placeholder);
                }
                
                const infoDiv = document.createElement('div');
                const titleStrong = document.createElement('strong');
                titleStrong.textContent = movie.title;
                infoDiv.appendChild(titleStrong);
                
                if (movie.release_date) {
                    const year = document.createTextNode(' (' + movie.release_date.split('-')[0] + ')');
                    infoDiv.appendChild(year);
                }
                
                movieEl.appendChild(infoDiv);
                movieEl.addEventListener('click', () => selectMovie(movie, isStart));
                resultsContainer.appendChild(movieEl);
            });
        }

        // Select a movie - simplified
        function selectMovie(movie, isStart) {
            console.log('Selecting movie:', movie.title, isStart ? 'as start' : 'as end');
            
            // Add movie to graph database
            graphDB.addMovie(movie);
            
            const selectedDiv = document.getElementById(isStart ? 'selectedStart' : 'selectedEnd');
            selectedDiv.innerHTML = '';
            
            const movieEl = document.createElement('div');
            movieEl.className = 'movie-item selected';
            
            let html = '<div style="display: flex; align-items: center; gap: 10px;">';
            
            if (movie.poster_path) {
                html += `<img src="https://image.tmdb.org/t/p/w200${movie.poster_path}" class="movie-poster" style="width: 40px; height: 60px; object-fit: cover; border-radius: 4px;">`;
            } else {
                html += '<div class="movie-poster" style="width: 40px; height: 60px; background: #333; border-radius: 4px;"></div>';
            }
            
            html += '<div>';
            html += `<strong>${movie.title}</strong>`;
            if (movie.release_date) {
                html += ` (${movie.release_date.split('-')[0]})`;
            }
            html += '</div></div>';
            
            movieEl.innerHTML = html;
            selectedDiv.appendChild(movieEl);
            
            // Clear search results
            document.getElementById(isStart ? 'startMovieResults' : 'endMovieResults').innerHTML = '';
            document.getElementById(isStart ? 'startMovieResults' : 'endMovieResults').style.display = 'none';
            
            // Update selected movie
            if (isStart) {
                startMovie = movie;
            } else {
                endMovie = movie;
            }
            
            // Enable find path button if both movies are selected
            document.getElementById('findPathBtn').disabled = !(startMovie && endMovie);
        }

        // Event listeners for search
        const startSearchInput = document.getElementById('startMovieSearch');
        const endSearchInput = document.getElementById('endMovieSearch');
        
        const debouncedStartSearch = debounce(async (query) => {
            if (query.length > 2) {
                const movies = await searchMovies(query);
                displaySearchResults(movies, document.getElementById('startMovieResults'), true);
            }
        }, 300);
        
        const debouncedEndSearch = debounce(async (query) => {
            if (query.length > 2) {
                const movies = await searchMovies(query);
                displaySearchResults(movies, document.getElementById('endMovieResults'), false);
            }
        }, 300);
        
        startSearchInput.addEventListener('input', (e) => debouncedStartSearch(e.target.value));
        endSearchInput.addEventListener('input', (e) => debouncedEndSearch(e.target.value));

        // Find path button handler
        document.getElementById('findPathBtn').addEventListener('click', async () => {
            if (!startMovie || !endMovie) return;
            
            // Clear existing visualization
            nodes = [];
            edges = [];
            
            // Reset progress bar
            document.getElementById('progressBar').style.width = '0%';
            
            // Show loading state
            const btn = document.getElementById('findPathBtn');
            btn.disabled = true;
            btn.textContent = 'Finding Path...';
            
            // Show search info
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.classList.add('active');
            
            try {
                // Progress callback
                const onProgress = (progress) => {
                    const percentage = Math.min((progress.explored / 500) * 100, 90);
                    document.getElementById('progressBar').style.width = percentage + '%';
                    searchInfo.textContent = `Exploring: ${progress.explored} nodes, ${progress.queued} in queue`;
                };
                
                const result = await graphDB.findOptimalPath(startMovie.id, endMovie.id, onProgress);
                
                if (result) {
                    visualizePath(result);
                    searchInfo.textContent = `Path found! Length: ${result.path.length} movies`;
                    setTimeout(() => searchInfo.classList.remove('active'), 3000);
                } else {
                    searchInfo.textContent = 'No connection found!';
                    setTimeout(() => searchInfo.classList.remove('active'), 3000);
                }
            } catch (error) {
                console.error('Path finding error:', error);
                searchInfo.textContent = 'Error finding path';
                setTimeout(() => searchInfo.classList.remove('active'), 3000);
            }
            
            // Reset progress bar
            setTimeout(() => {
                document.getElementById('progressBar').style.width = '0%';
            }, 1000);
            
            btn.disabled = false;
            btn.textContent = 'Connect Movies';
            
            // Save graph state
            graphDB.saveToStorage();
        });